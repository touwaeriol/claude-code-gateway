# 实现决策记录

本文档记录了在开发 Claude Code Gateway 过程中的重要技术决策及其理由。

## 1. 工具调用 ID 管理

### 决策
直接使用 MCP JSON-RPC 请求 ID 作为工具调用 ID，而不是生成新的 ID。

### 理由
- **简化映射**：避免维护请求 ID 到工具调用 ID 的映射
- **生命周期一致**：JSON-RPC 请求的生命周期与工具调用完全一致
- **易于调试**：一个 ID 贯穿整个调用链，方便追踪

### 实现
```typescript
const toolCallId = String(request.id); // 直接使用请求 ID
```

## 2. 资源清理策略

### 决策
采用自然生命周期管理，而不是在每个 HTTP 请求结束时强制清理。

### 理由
- **避免过度清理**：HTTP 请求结束不代表 Claude Code 会话结束
- **支持多轮对话**：同一个 Claude Code 会话可能跨越多个 HTTP 请求
- **简化逻辑**：让资源随其自然生命周期结束而清理

### 实现
- Claude Code 会话结束时（`finally` 块）自动清理相关工具调用
- 客户端断开时通过 `AbortController` 触发清理链
- 超时机制作为兜底保护

## 3. 工具结果传输方式

### 决策
要求客户端一次性发送完整的工具调用结果，不支持流式/分片传输。

### 理由
- **MCP 协议限制**：MCP 遵循请求-响应模式，不支持流式响应
- **OpenAI 标准**：OpenAI API 也要求完整的工具结果
- **简化实现**：避免处理分片、排序、重组的复杂性

### 影响
- 客户端需要在本地累积结果后一次性发送
- 适合大多数工具调用场景（API 调用、计算等）
- 对于真正需要流式的场景，建议在工具内部处理

## 4. 会话工具管理

### 决策
使用基于签名的缓存机制管理会话工具定义。

### 理由
- **性能优化**：相同的工具列表共享缓存，减少内存使用
- **会话隔离**：不同会话可以有不同的工具集
- **自动过期**：5分钟缓存避免内存泄漏

### 实现
```typescript
// 生成工具列表签名
const signature = createHash('sha256')
  .update(JSON.stringify(normalizedTools))
  .digest('hex')
  .substring(0, 16);
```

## 5. MCP 服务器类型

### 决策
使用 HTTP 类型的 MCP 服务器，而不是 stdio 或 SSE。

### 理由
- **集成简单**：HTTP 服务器容易集成到现有的 Express 应用
- **调试方便**：HTTP 请求容易监控和调试
- **兼容性好**：Claude Code SDK 对 HTTP MCP 支持良好

### 限制
- 必须遵循请求-响应模式
- 不支持服务器主动推送
- 每个工具调用都是独立的 HTTP 请求

## 6. 批量工具调用处理

### 决策
支持客户端在一个请求中发送多个工具调用结果。

### 理由
- **提高效率**：减少网络往返次数
- **原子性处理**：要么全部成功，要么全部失败
- **符合 OpenAI 规范**：OpenAI API 支持多个 tool 消息

### 实现
```typescript
const toolMessages = messages.filter(msg => msg.role === 'tool');
// 处理所有工具调用结果
```

## 7. 错误处理策略

### 决策
保持错误的原始信息，不过度包装。

### 理由
- **透明性**：让客户端看到真实的错误信息
- **调试友好**：保留完整的错误堆栈
- **避免混淆**：不隐藏潜在的问题

## 8. MCP 服务器职责分离

### 决策
将 MCP 服务器实现拆分为两个独立的类：MCPAuthServer 和 MCPGatewayServer。

### 理由
- **单一职责**：每个类只负责一个明确的功能
- **清晰的边界**：权限验证和工具执行逻辑分离
- **易于维护**：修改一个功能不影响另一个
- **更好的测试性**：可以独立测试每个服务器

### 实现
- `MCPAuthServer`：处理权限验证（approval_prompt）
- `MCPGatewayServer`：处理实际的工具调用
- 两者共享相同的 JSON-RPC 处理框架

## 总结

这些决策的核心原则是：
1. **简单优于复杂**：选择最直接的实现方式
2. **遵循标准**：严格遵循 MCP 和 OpenAI 协议规范
3. **自然生命周期**：让资源随其使用者的生命周期管理
4. **性能与正确性平衡**：在保证正确性的前提下优化性能
5. **职责分离**：每个组件只做一件事并做好